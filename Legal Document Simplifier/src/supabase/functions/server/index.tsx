import { Hono } from 'npm:hono';
import { cors } from 'npm:hono/cors';
import { logger } from 'npm:hono/logger';
import { createClient } from 'jsr:@supabase/supabase-js@2';
import * as kv from './kv_store.tsx';

const app = new Hono();

// Middleware
app.use('*', cors({
  origin: '*',
  allowHeaders: ['*'],
  allowMethods: ['POST', 'GET', 'OPTIONS', 'PUT', 'DELETE'],
}));
app.use('*', logger(console.log));

// Initialize Supabase client
const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

// Google Cloud Document AI integration
async function analyzeDocumentWithGoogleAI(fileContent: string, fileName: string) {
  const apiKey = Deno.env.get('GOOGLE_CLOUD_DOCUMENT_AI_API_KEY');
  
  if (!apiKey) {
    throw new Error('Google Cloud Document AI API key not configured');
  }

  try {
    // Use Google Generative AI (Gemini) for document analysis
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `You are a professional legal document analyst. Analyze the following legal document and provide a comprehensive analysis in JSON format. 

Document filename: ${fileName}
Document content: ${fileContent}

Please provide analysis in this exact JSON structure:
{
  "documentType": "string (e.g., 'Service Agreement', 'NDA', 'Employment Contract')",
  "complexity": "string (Low/Medium/High based on legal complexity)",
  "summary": "string (2-3 sentence executive summary)",
  "keyPoints": ["array of 4-6 most important clauses or terms"],
  "risks": ["array of 2-4 potential risks or unfavorable terms"],
  "recommendations": ["array of 3-5 actionable recommendations"],
  "plainLanguage": {
    "overview": "string (explain what this document does in simple terms)",
    "yourObligations": "string (what the reader must do)",
    "theirObligations": "string (what the other party must do)", 
    "exitTerms": "string (how to terminate or exit)",
    "importantDates": "string (key dates and deadlines)"
  }
}

Focus on practical, actionable insights that help non-lawyers understand the document.`
          }]
        }],
        generationConfig: {
          temperature: 0.3,
          maxOutputTokens: 2048,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Google AI API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!generatedText) {
      throw new Error('No analysis generated by Google AI');
    }

    // Extract JSON from the response (it might be wrapped in markdown)
    const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Failed to extract JSON from AI response');
    }

    const analysisData = JSON.parse(jsonMatch[0]);
    
    // Add metadata
    return {
      id: crypto.randomUUID(),
      fileName,
      uploadDate: new Date().toISOString(),
      ...analysisData
    };

  } catch (error) {
    console.log('Google AI analysis error:', error);
    throw error;
  }
}

// AI Document Analysis endpoint with Google Cloud Document AI
app.post('/make-server-630be9b7/analyze-document', async (c) => {
  try {
    const body = await c.req.json();
    const { fileName, fileContent, documentType } = body;
    
    console.log(`Starting analysis for document: ${fileName}`);
    
    let analysis;
    
    try {
      // Try to analyze with Google AI first
      analysis = await analyzeDocumentWithGoogleAI(fileContent, fileName);
      console.log('Successfully analyzed document with Google AI');
    } catch (aiError) {
      console.log('Google AI analysis failed, falling back to mock analysis:', aiError);
      
      // Fallback to enhanced mock analysis
      analysis = {
        id: crypto.randomUUID(),
        fileName,
        uploadDate: new Date().toISOString(),
        documentType: documentType || determineDocumentType(fileName, fileContent),
        complexity: determineComplexity(fileContent),
        summary: generateSummary(fileContent),
        keyPoints: extractKeyPoints(fileContent),
        risks: identifyRisks(fileContent),
        recommendations: generateRecommendations(fileContent),
        plainLanguage: {
          overview: 'This is a legal document that establishes rights, obligations, and terms between parties.',
          yourObligations: 'Review the document carefully to understand your specific responsibilities and commitments.',
          theirObligations: 'The other party has corresponding duties and obligations as outlined in the agreement.',
          exitTerms: 'Check for termination clauses, notice requirements, and any penalties for early exit.',
          importantDates: 'Pay attention to effective dates, deadlines, renewal dates, and expiration terms.'
        }
      };
    }
    
    return c.json({ analysis });
  } catch (error) {
    console.log('Error in document analysis endpoint:', error);
    return c.json({ error: 'Failed to analyze document', details: error.message }, 500);
  }
});

// Helper functions for fallback analysis
function determineDocumentType(fileName: string, content: string): string {
  const lowerFileName = fileName.toLowerCase();
  const lowerContent = content.toLowerCase();
  
  if (lowerFileName.includes('nda') || lowerContent.includes('non-disclosure') || lowerContent.includes('confidentiality')) {
    return 'Non-Disclosure Agreement';
  } else if (lowerFileName.includes('employment') || lowerContent.includes('employment') || lowerContent.includes('job offer')) {
    return 'Employment Agreement';
  } else if (lowerFileName.includes('service') || lowerContent.includes('services') || lowerContent.includes('consulting')) {
    return 'Service Agreement';
  } else if (lowerFileName.includes('lease') || lowerContent.includes('rental') || lowerContent.includes('premises')) {
    return 'Lease Agreement';
  } else if (lowerFileName.includes('contract') || lowerContent.includes('agreement') || lowerContent.includes('parties')) {
    return 'Contract Agreement';
  } else {
    return 'Legal Document';
  }
}

function determineComplexity(content: string): string {
  const wordCount = content.split(/\s+/).length;
  const legalTerms = ['whereas', 'heretofore', 'indemnify', 'liability', 'jurisdiction', 'arbitration', 'force majeure'];
  const legalTermCount = legalTerms.filter(term => content.toLowerCase().includes(term)).length;
  
  if (wordCount > 2000 || legalTermCount > 4) return 'High';
  if (wordCount > 800 || legalTermCount > 2) return 'Medium';
  return 'Low';
}

function generateSummary(content: string): string {
  // Simple keyword-based summary generation
  const lowerContent = content.toLowerCase();
  
  if (lowerContent.includes('confidential')) {
    return 'This document establishes confidentiality obligations between parties to protect sensitive information.';
  } else if (lowerContent.includes('employment') || lowerContent.includes('employee')) {
    return 'This employment agreement defines the terms of the working relationship between employer and employee.';
  } else if (lowerContent.includes('service') || lowerContent.includes('consulting')) {
    return 'This service agreement outlines the terms for professional services to be provided between parties.';
  } else {
    return 'This legal document establishes terms, conditions, and obligations between the involved parties.';
  }
}

function extractKeyPoints(content: string): string[] {
  const points = [];
  const lowerContent = content.toLowerCase();
  
  if (lowerContent.includes('term') || lowerContent.includes('duration')) {
    points.push('Contract duration and term specifications');
  }
  if (lowerContent.includes('payment') || lowerContent.includes('compensation')) {
    points.push('Payment terms and compensation details');
  }
  if (lowerContent.includes('termination') || lowerContent.includes('terminate')) {
    points.push('Termination clauses and exit procedures');
  }
  if (lowerContent.includes('confidential') || lowerContent.includes('proprietary')) {
    points.push('Confidentiality and proprietary information protection');
  }
  if (lowerContent.includes('liability') || lowerContent.includes('damages')) {
    points.push('Liability limitations and damage provisions');
  }
  if (lowerContent.includes('intellectual property') || lowerContent.includes('copyright')) {
    points.push('Intellectual property rights and ownership');
  }
  
  // Ensure we have at least 4 points
  while (points.length < 4) {
    const defaultPoints = [
      'Rights and obligations of all parties',
      'Governing law and jurisdiction clauses', 
      'Amendment and modification procedures',
      'Dispute resolution mechanisms'
    ];
    points.push(defaultPoints[points.length]);
  }
  
  return points.slice(0, 6);
}

function identifyRisks(content: string): string[] {
  const risks = [];
  const lowerContent = content.toLowerCase();
  
  if (lowerContent.includes('penalty') || lowerContent.includes('fine')) {
    risks.push('Potential penalty fees or fines for non-compliance');
  }
  if (lowerContent.includes('indemnify') || lowerContent.includes('hold harmless')) {
    risks.push('Broad indemnification clauses that may increase liability exposure');
  }
  if (lowerContent.includes('exclusive') || lowerContent.includes('sole')) {
    risks.push('Exclusive obligations that may limit flexibility');
  }
  if (lowerContent.includes('automatic renewal') || lowerContent.includes('auto-renew')) {
    risks.push('Automatic renewal terms that may be difficult to exit');
  }
  
  // Ensure we have at least 2 risks
  while (risks.length < 2) {
    const defaultRisks = [
      'Potential for disputes due to ambiguous language',
      'Limited recourse options for breach of contract'
    ];
    risks.push(defaultRisks[risks.length]);
  }
  
  return risks.slice(0, 4);
}

function generateRecommendations(content: string): string[] {
  const recommendations = [
    'Have a qualified attorney review this document before signing',
    'Clarify any ambiguous terms or conditions with the other party',
    'Ensure all key business terms are clearly defined and agreed upon',
    'Consider adding specific performance metrics and remedies for breaches',
    'Review insurance coverage to ensure adequate protection'
  ];
  
  return recommendations.slice(0, 5);
}

// Store legal document analysis
app.post('/make-server-630be9b7/document-analysis', async (c) => {
  try {
    const body = await c.req.json();
    const { fileName, documentType, analysis, userId } = body;
    
    const analysisData = {
      id: crypto.randomUUID(),
      fileName,
      documentType,
      analysis,
      userId: userId || 'anonymous',
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(`analysis:${analysisData.id}`, analysisData);
    
    return c.json({ success: true, id: analysisData.id });
  } catch (error) {
    console.log('Error storing document analysis:', error);
    return c.json({ error: 'Failed to store analysis' }, 500);
  }
});

// Get user's document analyses
app.get('/make-server-630be9b7/document-analyses/:userId', async (c) => {
  try {
    const userId = c.req.param('userId');
    const analyses = await kv.getByPrefix(`analysis:`);
    
    const userAnalyses = analyses
      .filter(item => item.value.userId === userId)
      .map(item => item.value)
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    
    return c.json({ analyses: userAnalyses });
  } catch (error) {
    console.log('Error fetching document analyses:', error);
    return c.json({ error: 'Failed to fetch analyses' }, 500);
  }
});

// Delete document analysis
app.delete('/make-server-630be9b7/document-analysis/:id', async (c) => {
  try {
    const id = c.req.param('id');
    await kv.del(`analysis:${id}`);
    
    return c.json({ success: true });
  } catch (error) {
    console.log('Error deleting document analysis:', error);
    return c.json({ error: 'Failed to delete analysis' }, 500);
  }
});

// Health check
app.get('/make-server-630be9b7/health', (c) => {
  return c.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

Deno.serve(app.fetch);